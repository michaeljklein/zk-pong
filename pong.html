<!-- https://gist.githubusercontent.com/straker/81b59eecf70da93af396f963596dfdc5/raw/a54a0d874ea87ef07ac5b76d032868a3a702c4b6/pong.html -->
<!DOCTYPE html>
<html>
<head>
  <title>Basic Pong HTML Game</title>
  <meta charset="UTF-8">
  <style>
    html, body {
      height: 100%;
      margin: 0;
    }

    body {
      background: black;
      display: flex;
      align-items: center;
      justify-content: center;
    }
  </style>
</head>
<body>
<canvas width="750" height="585" id="game"></canvas>
<script>

  // https://stackoverflow.com/a/30832210
  // Function to download data to a file
  function download_as_file(data, filename, type) {
      var file = new Blob([data], {type: type});
      if (window.navigator.msSaveOrOpenBlob) // IE10+
          window.navigator.msSaveOrOpenBlob(file, filename);
      else { // Others
          var a = document.createElement("a"),
                  url = URL.createObjectURL(file);
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          setTimeout(function() {
              document.body.removeChild(a);
              window.URL.revokeObjectURL(url);  
          }, 0); 
      }
  }

  const canvas = document.getElementById('game');
  const canvas_width = canvas.width;
  const canvas_height = canvas.height;
  const context = canvas.getContext('2d');

  const grid_size = 15;
  const paddleHeight = grid_size * 5; // 80
  const maxPaddleY = canvas_height - grid_size - paddleHeight;
  const game_ticks = 128;
  const paddleSpeed = 6;
  const ballSpeed = 5;

  const canvas_width_half = 375; // == 750 // 2
  const canvas_height_half = 292; // == 585 // 2
  const paddleHeight_half = 40;

  const ball_x0 = canvas_width_half;
  const ball_y0 = canvas_height_half;
  const paddle_y0 = canvas_height_half - paddleHeight_half;

  const leftPaddle = {
    // start in the middle of the game on the left side
    x: grid_size * 2,
    y: paddle_y0,
    width: grid_size,
    height: paddleHeight,

    // paddle velocity: 0 | paddleSpeed
    dy: 0,

    score: 0
  };
  const rightPaddle = {
    // start in the middle of the game on the right side
    x: canvas_width - grid_size * 3,
    y: paddle_y0,
    width: grid_size,
    height: paddleHeight,

    // paddle velocity: 0 | paddleSpeed
    dy: 0,

    score: 0
  };
  const ball = {
    // start in the middle of the game
    x: ball_x0,
    y: ball_y0,
    width: grid_size,
    height: grid_size,

    // ball velocity (start going to the top-right corner)
    dx: ballSpeed,
    dy: -ballSpeed,

    tick: 0
  };

  // check for collision between two objects using axis-aligned bounding box (AABB)
  // @see https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection
  function collides(obj1, obj2) {
    return obj1.x < obj2.x + obj2.width &&
           obj1.x + obj1.width > obj2.x &&
           obj1.y < obj2.y + obj2.height &&
           obj1.y + obj1.height > obj2.y;
  }

  // global game log
  var game_log = [];

  // game loop
  function loop() {
    // check if game over
    if (game_ticks <= ball.tick) {
      if (leftPaddle.score > rightPaddle.score) {
        alert(`Game over: left player won with ${leftPaddle.score} points!`)
      } else if (rightPaddle.score > leftPaddle.score) {
        alert(`Game over: right player won with ${rightPaddle.score} points!`)
      } else {
        // TODO tie breaker?
        alert(`Game tied!`)
      }

      download_as_file(JSON.stringify(game_log), 'ping_game_log.json', 'text/plain');
      return
    }

    // move paddles by their velocity
    leftPaddle.y += leftPaddle.dy;
    rightPaddle.y += rightPaddle.dy;

    // prevent paddles from going through walls
    if (leftPaddle.y < grid_size) {
      leftPaddle.y = grid_size;
    }
    else if (leftPaddle.y > maxPaddleY) {
      leftPaddle.y = maxPaddleY;
    }

    if (rightPaddle.y < grid_size) {
      rightPaddle.y = grid_size;
    }
    else if (rightPaddle.y > maxPaddleY) {
      rightPaddle.y = maxPaddleY;
    }

    // move ball by its velocity
    ball.x += ball.dx;
    ball.y += ball.dy;

    // prevent ball from going through walls by changing its velocity
    if (ball.y < grid_size) {
      ball.y = grid_size;
      ball.dy *= -1;
    }
    else if (ball.y + grid_size > canvas_height - grid_size) {
      ball.y = canvas_height - grid_size * 2;
      ball.dy *= -1;
    }

    // points scored: reset ball if it goes past paddle
    if (ball.x < 0 || ball.x > canvas_width) {

      if (ball.x < 0) {
        rightPaddle.score += 1;
      } else {
        leftPaddle.score += 1;
      }

      ball.x = ball_x0;
      ball.y = ball_y0;

      // swap directions and reset speed
      ball.dx = ballSpeed * Math.sign(ball.dx) * -1;
      ball.dy = -ballSpeed * Math.sign(ball.dy) * -1;
    }

    // check to see if ball collides with paddle. if they do change x velocity
    if (collides(ball, leftPaddle)) {
      ball.dx *= -1;
      ball.dx += Math.sign(ball.dx);
      ball.dy += Math.sign(ball.dy);

      // move ball next to the paddle otherwise the collision will happen again
      // in the next frame
      ball.x = leftPaddle.x + leftPaddle.width;
    }
    else if (collides(ball, rightPaddle)) {
      ball.dx *= -1;
      ball.dx += Math.sign(ball.dx);
      ball.dy += Math.sign(ball.dy);

      // move ball next to the paddle otherwise the collision will happen again
      // in the next frame
      ball.x = rightPaddle.x - ball.width;
    }

    ball.tick += 1;

    let game_log_item = {
      ball_x: ball.x,
      ball_y: ball.y,
      ball_dx: ball.dx,
      ball_dy: ball.dy,
      ball_tick: ball.tick,
      leftPaddle_x: leftPaddle.x,
      leftPaddle_y: leftPaddle.y,
      leftPaddle_dy: leftPaddle.dy,
      leftPaddle_score: leftPaddle.score,
      rightPaddle_x: rightPaddle.x,
      rightPaddle_y: rightPaddle.y,
      rightPaddle_dy: rightPaddle.dy,
      rightPaddle_score: rightPaddle.score,
    };
    console.log(game_log_item);
    game_log.push(game_log_item);

    ////////////////////////////////////
    // ANIMATION
    ////////////////////////////////////

    // get next frame and clear canvas
    requestAnimationFrame(loop);
    context.clearRect(0, 0, canvas_width,canvas_height);

    // draw paddles
    context.fillStyle = 'white';
    context.fillRect(leftPaddle.x, leftPaddle.y, leftPaddle.width, leftPaddle.height);
    context.fillRect(rightPaddle.x, rightPaddle.y, rightPaddle.width, rightPaddle.height);

    // draw ball
    context.fillRect(ball.x, ball.y, ball.width, ball.height);

    // draw walls
    context.fillStyle = 'lightgrey';
    context.fillRect(0, 0, canvas_width, grid_size);
    context.fillRect(0, canvas_height - grid_size, canvas_width, canvas_height);

    // draw dotted line down the middle
    for (let i = grid_size; i < canvas_height - grid_size; i += grid_size * 2) {
      context.fillRect(canvas_width / 2 - grid_size / 2, i, grid_size, grid_size);
    }

    let score_height = canvas_height - 32;
    context.fillText(`Score: ${leftPaddle.score}`, 32, score_height);
    context.fillText(`Score: ${rightPaddle.score}`, canvas_width - 64, score_height);
  }

  // listen to keyboard events to move the paddles
  document.addEventListener('keydown', function(e) {
    // up arrow key
    if (e.which === 38) {
      rightPaddle.dy = -paddleSpeed;
    }
    // down arrow key
    else if (e.which === 40) {
      rightPaddle.dy = paddleSpeed;
    }

    // w key
    if (e.which === 87) {
      leftPaddle.dy = -paddleSpeed;
    }
    // a key
    else if (e.which === 83) {
      leftPaddle.dy = paddleSpeed;
    }
  });

  // listen to keyboard events to stop the paddle if key is released
  document.addEventListener('keyup', function(e) {
    if (e.which === 38 || e.which === 40) {
      rightPaddle.dy = 0;
    }

    if (e.which === 83 || e.which === 87) {
      leftPaddle.dy = 0;
    }
  });

  // start the game
  requestAnimationFrame(loop);
</script>
</body>
</html>
