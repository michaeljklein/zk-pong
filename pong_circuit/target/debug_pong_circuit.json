{"debug_symbols":[{"locations":{"0":[{"span":{"start":11003,"end":11009},"file":0}],"1":[{"span":{"start":11003,"end":11009},"file":0}],"2":[{"span":{"start":11003,"end":11009},"file":0}],"3":[{"span":{"start":11003,"end":11009},"file":0}],"4":[{"span":{"start":11003,"end":11009},"file":0}]}}],"file_map":{"0":{"source":"// Pong circuit\n//\n// Kernel for ensuring Pong game rules are valid for a particular state transition\n\n\n//////////////////////////////////////////\n// utils\n//////////////////////////////////////////\n\nfn signum(x: i64) -> i64 {\n  if (x < 0) {\n    -1\n  } else if (x == 0) {\n    0\n  } else {\n    1\n  }\n}\n\n//////////////////////////////////////////\n// end utils\n//////////////////////////////////////////\n\nglobal canvas_width: i64 = 750;\nglobal canvas_height: i64 = 585;\n\nglobal grid_size: i64 = 15;\nglobal paddleHeight: i64 = 80; // grid_size * 5;\nglobal maxPaddleY: i64 = 495; // canvas_height - grid_size - paddleHeight;\nglobal max_game_ticks: i64 = 128;\nglobal paddleSpeed: i64 = 6;\nglobal ballSpeed: i64 = 5;\n\nglobal canvas_width_half: i64 = 375; // == 750 // 2\nglobal canvas_height_half: i64 = 292; // == 585 // 2\nglobal paddleHeight_half: i64 = 40;\nglobal paddle_y0: i64 = 252; // canvas_height_half - paddleHeight_half;\n\n\nstruct GameObject {\n  x: i64,\n  y: i64,\n  width: i64,\n  height: i64,\n  dy: i64,\n}\n\n\n// // check for collision between two objects using axis-aligned bounding box (AABB)\n// // @see https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection\n// function collides(obj1, obj2) {\n//   return obj1.x < obj2.x + obj2.width &&\n//          obj1.x + obj1.width > obj2.x &&\n//          obj1.y < obj2.y + obj2.height &&\n//          obj1.y + obj1.height > obj2.y;\n// }\nfn collides(obj1: GameObject, obj2: GameObject) -> bool {\n  obj1.x < obj2.x + obj2.width &\n  obj1.x + obj1.width > obj2.x &\n  obj1.y < obj2.y + obj2.height &\n  obj1.y + obj1.height > obj2.y\n}\n\n\n// assert initial state valid\nfn init_pong(\n  out_ball_x: i64,\n  out_ball_y: i64,\n  out_ball_dx: i64,\n  out_ball_dy: i64,\n  out_game_tick: i64,\n  out_leftPaddle_x: i64,\n  out_leftPaddle_y: i64,\n  out_leftPaddle_dy: i64,\n  out_leftPaddle_score: i64,\n  out_rightPaddle_x: i64,\n  out_rightPaddle_y: i64,\n  out_rightPaddle_dy: i64,\n  out_rightPaddle_score: i64\n) {\n  let leftPaddle = GameObject {\n      x: grid_size * 2,\n      y: paddle_y0,\n      width: grid_size,\n      height: paddleHeight,\n      dy: 0,\n  };\n\n  let rightPaddle = GameObject {\n      x: canvas_width - grid_size * 3,\n      y: paddle_y0,\n      width: grid_size,\n      height: paddleHeight,\n      dy: 0,\n  };\n\n  let ball = GameObject {\n    x: canvas_width_half,\n    y: canvas_height_half,\n    width: grid_size,\n    height: grid_size,\n    dy: -ballSpeed,\n  };\n\n  let leftPaddle_score: i64 = 0;\n  let rightPaddle_score: i64 = 0;\n  let game_tick: i64 = 0;\n  let ball_dx: i64 = ballSpeed;\n\n  assert(ball.x            == out_ball_x,            \"unexpected initial tick: ball.x           \");\n  assert(ball.y            == out_ball_y,            \"unexpected initial tick: ball.y           \");\n  assert(ball_dx           == out_ball_dx,           \"unexpected initial tick: ball_dx          \");\n  assert(ball.dy           == out_ball_dy,           \"unexpected initial tick: ball.dy          \");\n  assert(game_tick         == out_game_tick,         \"unexpected initial tick: game_tick        \");\n  assert(leftPaddle.x      == out_leftPaddle_x,      \"unexpected initial tick: leftPaddle_x     \");\n  assert(leftPaddle.y      == out_leftPaddle_y,      \"unexpected initial tick: leftPaddle_y     \");\n  assert(leftPaddle.dy     == out_leftPaddle_dy,     \"unexpected initial tick: leftPaddle_dy    \");\n  assert(leftPaddle_score  == out_leftPaddle_score,  \"unexpected initial tick: leftPaddle_score \");\n  assert(rightPaddle.x     == out_rightPaddle_x,     \"unexpected initial tick: rightPaddle_x    \");\n  assert(rightPaddle.y     == out_rightPaddle_y,     \"unexpected initial tick: rightPaddle_y    \");\n  assert(rightPaddle.dy    == out_rightPaddle_dy,    \"unexpected initial tick: rightPaddle_dy   \");\n  assert(rightPaddle_score == out_rightPaddle_score, \"unexpected initial tick: rightPaddle_score\");\n}\n\n\n// validate state change on following i/o\n//\n// ball_x: i64\n// ball_y: i64\n// ball_dx: i64\n// ball_dy: i64\n// ball_tick: i64\n// leftPaddle_x: i64\n// leftPaddle_y: i64\n// leftPaddle_dy: i64\n// leftPaddle_score: i64\n// rightPaddle_x: i64\n// rightPaddle_y: i64\n// rightPaddle_dy: i64\n// rightPaddle_score: i64\nfn step_pong(\n  in_ball_x: i64,\n  in_ball_y: i64,\n  in_ball_dx: i64,\n  in_ball_dy: i64,\n  in_game_tick: i64,\n  in_leftPaddle_x: i64,\n  in_leftPaddle_y: i64,\n  in_leftPaddle_dy: i64,\n  in_leftPaddle_score: i64,\n  in_rightPaddle_x: i64,\n  in_rightPaddle_y: i64,\n  in_rightPaddle_dy: i64,\n  in_rightPaddle_score: i64,\n\n  out_ball_x: i64,\n  out_ball_y: i64,\n  out_ball_dx: i64,\n  out_ball_dy: i64,\n  out_game_tick: i64,\n  out_leftPaddle_x: i64,\n  out_leftPaddle_y: i64,\n  out_leftPaddle_dy: i64,\n  out_leftPaddle_score: i64,\n  out_rightPaddle_x: i64,\n  out_rightPaddle_y: i64,\n  out_rightPaddle_dy: i64,\n  out_rightPaddle_score: i64\n) {\n  let mut leftPaddle = GameObject {\n      x: in_leftPaddle_x,\n      y: in_leftPaddle_y,\n      width: grid_size,\n      height: paddleHeight,\n      dy: in_leftPaddle_dy,\n  };\n\n  let mut rightPaddle = GameObject {\n      x: in_rightPaddle_x,\n      y: in_rightPaddle_y,\n      width: grid_size,\n      height: paddleHeight,\n      dy: in_rightPaddle_dy,\n  };\n\n  let mut ball = GameObject {\n    x: in_ball_x,\n    y: in_ball_y,\n    width: grid_size,\n    height: grid_size,\n    dy: in_ball_dy,\n  };\n\n  let mut leftPaddle_score = in_leftPaddle_score;\n  let mut rightPaddle_score = in_rightPaddle_score;\n  let mut game_tick = in_game_tick;\n  let mut ball_dx = in_ball_dx;\n\n  // game active\n  assert(game_tick < max_game_ticks, \"game tick past end of game\");\n\n  // paddle velocity valid\n  assert((leftPaddle.dy == 0) | (leftPaddle.dy == -paddleSpeed) | (leftPaddle.dy == paddleSpeed));\n  assert((rightPaddle.dy == 0) | (rightPaddle.dy == -paddleSpeed) | (rightPaddle.dy == paddleSpeed));\n\n  // move paddles by their velocity\n  leftPaddle.y += leftPaddle.dy;\n  rightPaddle.y += rightPaddle.dy;\n\n  // prevent paddles from going through walls\n  if (leftPaddle.y < grid_size) {\n    leftPaddle.y = grid_size;\n  }\n  else if (leftPaddle.y > maxPaddleY) {\n    leftPaddle.y = maxPaddleY;\n  }\n  \n  if (rightPaddle.y < grid_size) {\n    rightPaddle.y = grid_size;\n  }\n  else if (rightPaddle.y > maxPaddleY) {\n    rightPaddle.y = maxPaddleY;\n  }\n\n  // move ball by its velocity\n  ball.x += ball_dx;\n  ball.y += ball.dy;\n\n  // prevent ball from going through walls by changing its velocity\n  if (ball.y < grid_size) {\n    ball.y = grid_size;\n    ball.dy *= -1;\n  }\n  else if (ball.y + grid_size > canvas_height - grid_size) {\n    ball.y = canvas_height - grid_size * 2;\n    ball.dy *= -1;\n  }\n\n  // points scored: reset ball if it goes past paddle\n  if (ball.x < 0 | ball.x > canvas_width) {\n  \n    if (ball.x < 0) {\n      rightPaddle_score += 1;\n    } else {\n      leftPaddle_score += 1;\n    }\n  \n    ball.x = canvas_width_half;\n    ball.y = canvas_height_half;\n  \n    // swap directions and reset speed\n    ball_dx = ballSpeed * signum(ball_dx) * -1;\n    ball.dy = -ballSpeed * signum(ball.dy) * -1;\n  }\n\n  // check to see if ball collides with paddle. if they do change x velocity\n  if (collides(ball, leftPaddle)) {\n    ball_dx *= -1;\n    ball_dx += signum(ball_dx);\n    ball.dy += signum(ball.dy);\n  \n    // move ball next to the paddle otherwise the collision will happen again\n    // in the next frame\n    ball.x = leftPaddle.x + leftPaddle.width;\n  }\n  else if (collides(ball, rightPaddle)) {\n    ball_dx *= -1;\n    ball_dx += signum(ball_dx);\n    ball.dy += signum(ball.dy);\n  \n    // move ball next to the paddle otherwise the collision will happen again\n    // in the next frame\n    ball.x = rightPaddle.x - ball.width;\n  }\n\n  game_tick += 1;\n\n  assert(ball.x            == out_ball_x,            \"unexpected end of tick: ball.x           \");\n  assert(ball.y            == out_ball_y,            \"unexpected end of tick: ball.y           \");\n  assert(ball_dx           == out_ball_dx,           \"unexpected end of tick: ball_dx          \");\n  assert(ball.dy           == out_ball_dy,           \"unexpected end of tick: ball.dy          \");\n  assert(game_tick         == out_game_tick,         \"unexpected end of tick: game_tick        \");\n  assert(leftPaddle.x      == out_leftPaddle_x,      \"unexpected end of tick: leftPaddle_x     \");\n  assert(leftPaddle.y      == out_leftPaddle_y,      \"unexpected end of tick: leftPaddle_y     \");\n  assert(leftPaddle.dy     == out_leftPaddle_dy,     \"unexpected end of tick: leftPaddle_dy    \");\n  assert(leftPaddle_score  == out_leftPaddle_score,  \"unexpected end of tick: leftPaddle_score \");\n  assert(rightPaddle.x     == out_rightPaddle_x,     \"unexpected end of tick: rightPaddle_x    \");\n  assert(rightPaddle.y     == out_rightPaddle_y,     \"unexpected end of tick: rightPaddle_y    \");\n  assert(rightPaddle.dy    == out_rightPaddle_dy,    \"unexpected end of tick: rightPaddle_dy   \");\n  assert(rightPaddle_score == out_rightPaddle_score, \"unexpected end of tick: rightPaddle_score\");\n}\n\n\n\n// end of game assertions\nfn final_step(\n  out_game_tick: i64,\n  out_leftPaddle_score: i64,\n  out_leftPaddle_won: bool,\n  out_rightPaddle_score: i64,\n  out_rightPaddle_won: bool,\n) {\n  if (max_game_ticks == out_game_tick) {\n    if (out_leftPaddle_score > out_rightPaddle_score) {\n      assert(out_leftPaddle_won);\n      assert(!out_rightPaddle_won);\n    } else if (out_rightPaddle_score > out_leftPaddle_score) {\n      assert(!out_leftPaddle_won);\n      assert(out_rightPaddle_won);\n    } else {\n      assert(!out_leftPaddle_won);\n      assert(!out_rightPaddle_won);\n    }\n  }\n}\n\n\nfn main(x: Field, y: pub Field) {\n\n  let leftPaddle = GameObject {\n      x: grid_size * 2,\n      y: paddle_y0,\n      width: grid_size,\n      height: paddleHeight,\n      dy: 0,\n  };\n\n  let rightPaddle = GameObject {\n      x: canvas_width - grid_size * 3,\n      y: paddle_y0,\n      width: grid_size,\n      height: paddleHeight,\n      dy: 0,\n  };\n\n  let ball = GameObject {\n    x: canvas_width_half,\n    y: canvas_height_half,\n    width: grid_size,\n    height: grid_size,\n    dy: -ballSpeed,\n  };\n\n  let leftPaddle_score: i64 = 0;\n  let rightPaddle_score: i64 = 0;\n  let game_tick: i64 = 0;\n  let ball_dx: i64 = ballSpeed;\n\n\n  init_pong(\n    ball.x,\n    ball.y,\n    ball_dx,\n    ball.dy,\n    game_tick,\n    leftPaddle.x,\n    leftPaddle.y,\n    leftPaddle.dy,\n    leftPaddle_score,\n    rightPaddle.x,\n    rightPaddle.y,\n    rightPaddle.dy,\n    rightPaddle_score,\n  );\n\n  step_pong(\n    ball.x,\n    ball.y,\n    ball_dx,\n    ball.dy,\n    game_tick,\n    leftPaddle.x,\n    leftPaddle.y,\n    leftPaddle.dy,\n    leftPaddle_score,\n    rightPaddle.x,\n    rightPaddle.y,\n    rightPaddle.dy,\n    rightPaddle_score,\n\n    ball.x + ball_dx,\n    ball.y + ball.dy,\n    ball_dx,\n    ball.dy,\n    game_tick + 1,\n    leftPaddle.x,\n    leftPaddle.y,\n    leftPaddle.dy,\n    leftPaddle_score,\n    rightPaddle.x,\n    rightPaddle.y,\n    rightPaddle.dy,\n    rightPaddle_score,\n  );\n\n  final_step(\n    max_game_ticks,\n    leftPaddle_score,\n    false, // out_leftPaddle_won\n    rightPaddle_score,\n    false, // out_rightPaddle_won\n  );\n\n  assert(x != y);\n}\n\n#[test]\nfn test_main() {\n    main(1, 2);\n\n    // Uncomment to make test fail\n    // main(1, 1);\n}\n\n","path":"/Users/michaelklein/Coding/noir/zk-pong/pong_circuit/src/main.nr"}},"warnings":[]}