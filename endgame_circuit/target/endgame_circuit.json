{"noir_version":"0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704","hash":2150781435071863648,"abi":{"parameters":[{"name":"index","type":{"kind":"field"},"visibility":"private"},{"name":"game_log","type":{"kind":"array","length":10,"type":{"kind":"struct","path":"pong::GameState","fields":[{"name":"ball_x","type":{"kind":"integer","sign":"signed","width":64}},{"name":"ball_y","type":{"kind":"integer","sign":"signed","width":64}},{"name":"ball_dx","type":{"kind":"integer","sign":"signed","width":64}},{"name":"ball_dy","type":{"kind":"integer","sign":"signed","width":64}},{"name":"game_tick","type":{"kind":"integer","sign":"signed","width":64}},{"name":"is_first_player","type":{"kind":"boolean"}},{"name":"leftPaddle_x","type":{"kind":"integer","sign":"signed","width":64}},{"name":"leftPaddle_y","type":{"kind":"integer","sign":"signed","width":64}},{"name":"leftPaddle_score","type":{"kind":"integer","sign":"signed","width":64}},{"name":"leftPaddle_won","type":{"kind":"boolean"}},{"name":"rightPaddle_x","type":{"kind":"integer","sign":"signed","width":64}},{"name":"rightPaddle_y","type":{"kind":"integer","sign":"signed","width":64}},{"name":"rightPaddle_score","type":{"kind":"integer","sign":"signed","width":64}},{"name":"rightPaddle_won","type":{"kind":"boolean"}}]}},"visibility":"private"},{"name":"game_moves","type":{"kind":"array","length":10,"type":{"kind":"struct","path":"pong::GameMove","fields":[{"name":"leftPaddle_dy","type":{"kind":"integer","sign":"signed","width":64}},{"name":"rightPaddle_dy","type":{"kind":"integer","sign":"signed","width":64}}]}},"visibility":"private"},{"name":"signatures","type":{"kind":"array","length":10,"type":{"kind":"struct","path":"Sig","fields":[{"name":"bytes","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}}]}},"visibility":"private"},{"name":"user_1","type":{"kind":"struct","path":"Pubkey","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]},"visibility":"private"},{"name":"user_2","type":{"kind":"struct","path":"Pubkey","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"game_log":[{"start":1,"end":141}],"game_moves":[{"start":141,"end":161}],"index":[{"start":0,"end":1}],"signatures":[{"start":161,"end":801}],"user_1":[{"start":801,"end":803}],"user_2":[{"start":803,"end":805}]},"return_type":null,"return_witnesses":[]},"bytecode":"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","debug_symbols":"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","file_map":{"16":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n    \n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(_self: Self, _bit_size: u32) -> [u1] {}\n    \n    #[builtin(to_be_bits)]\n    fn __to_be_bits(_self: Self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(_self: Self, _bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(_self: Self, _radix: u32, _result_len: u32) -> [u8] {}\n    \n    #[builtin(to_be_radix)]\n    fn __to_be_radix(_self: Self, _radix: u32, _result_len: u32) -> [u8] {}\n\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x âˆˆ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> Field {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"24":{"source":"mod poseidon;\nmod mimc;\n\n#[foreign(sha256)]\npub fn sha256<N>(_input: [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake2s)]\npub fn blake2s<N>(_input: [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake3)]\npub fn blake3<N>(_input: [u8; N]) -> [u8; 32] {}\n\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint {\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(_input: [Field; N], _separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\npub fn pedersen_hash<N>(input: [Field; N]) -> Field {\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(_input: [Field; N], _separator: u32) -> Field {}\n\npub fn hash_to_field<N>(_input: [Field; N]) -> Field {\n    let mut inputs_as_bytes = [];\n\n    for i in 0..N {\n        let input_bytes = _input[i].to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\npub fn keccak256<N>(_input: [u8; N], _message_size: u32) -> [u8; 32] {}\n\n","path":"std/hash.nr"},"39":{"source":"// Endgame circuit\n//\n// Kernel for certifying a game log once it's ended\n\nuse dep::std;\nuse dep::pong::{GameMove, GameState, init_pong, step_pong, final_step_pong, hash_game_state};\n\n\n// global MAX_PINGS = 256;\nglobal MAX_PINGS = 10;\n\nstruct Sig {\n  bytes: [u8; 64],\n}\n\n\nstruct Pubkey {\n  x: Field,\n  y: Field,\n}\n\nimpl Pubkey {\n  fn verify(self, sig: Sig, x: Field) {\n    let message_slice = x.to_le_radix(256, 32);\n    let mut message: [u8; 32] = [0; 32];\n    for i in 0..32 {\n        message[i] = message_slice[i];\n    }\n    // assert(std::ecdsa_secp256k1::verify_signature(self.x, self.y, sig.bytes, message));\n    assert(std::schnorr::verify_signature(self.x, self.y, sig.bytes, message));\n  }\n}\n\n\ntrait StepState<T> {\n  fn assert_initial_state(self);\n  fn assert_step(self, move: T, new_state: Self);\n  fn assert_final_state(self);\n  fn is_first_user(self) -> bool;\n  fn hash_to_field(self, move: T) -> Field;\n}\n\nimpl StepState<GameMove> for GameState {\n  fn assert_initial_state(self) {\n    init_pong(self)\n  }\n\n  fn assert_step(self, move: GameMove, new_state: Self) {\n    step_pong(self, move, new_state)\n  }\n\n  fn assert_final_state(self) {\n    final_step_pong(self)\n  }\n\n  fn is_first_user(self) -> bool {\n    self.is_first_player\n  }\n\n  fn hash_to_field(self, move: GameMove) -> Field {\n    hash_game_state(self, move)\n  }\n}\n\n\n// step kernel: (state_N, state_N', move_N', sig_N')\n// - state_N' = step(move_N', state_N)\n// - verify(p(N % 2), state_N', sig_N')\n//\n// if i == 0:\n//   // initialize\n//   old_state = initial_state\n//   new_state = game_log[i].0\n//   move      = game_log[i].1\n//   sig       = game_log[i].2\n// else:\n//   // step\n//   old_state = game_log[i].0\n//   new_state = game_log[i+1].0\n//   move      = game_log[i+1].1\n//   sig       = game_log[i+1].2\n//\n// step_kernel(old_state, new_state, move, sig)\n//\n// // finalize\n// if index + 1 == MAX_PINGS:\n//   finalize_kernel\n// end\nfn step_kernel<S, T>(\n  old_state: S,\n  new_state: S,\n  move: T,\n  index: Field,\n  sig: Sig,\n  user_1: Pubkey,\n  user_2: Pubkey,\n)\nwhere\n  S: StepState<T>\n{\n    // bootstrap with old_state = new_state = initial_state\n    if (index == 0) {\n        old_state.assert_initial_state();\n        new_state.assert_initial_state();\n    }\n\n    if (index + 1 == MAX_PINGS) {\n        new_state.assert_final_state();\n    }\n\n    // do this in state.assert_step()\n    // assert(old_state.is_first_user != new_state.is_first_user);\n    old_state.assert_step(move, new_state);\n\n    let current_user = if new_state.is_first_user() {\n        user_1\n    } else {\n        user_2\n    };\n    current_user.verify(sig, new_state.hash_to_field(move));\n}\n\nfn main(\n  index: Field,\n  game_log: [GameState; MAX_PINGS],\n  game_moves: [GameMove; MAX_PINGS],\n  signatures: [Sig; MAX_PINGS],\n  user_1: Pubkey,\n  user_2: Pubkey,\n) {\n  if (index == 0) {\n    assert(game_moves[0].leftPaddle_dy == game_moves[1].leftPaddle_dy);\n    assert(game_moves[0].rightPaddle_dy == game_moves[1].rightPaddle_dy);\n    assert(signatures[0].bytes == signatures[1].bytes);\n  }\n  step_kernel(\n    game_log[index], \n    game_log[index+1], \n    game_moves[index+1], \n    index,\n    signatures[index+1], \n    user_1,\n    user_2\n  )\n}\n\n","path":"/Users/michaelklein/Coding/noir/zk-pong/endgame_circuit/src/main.nr"},"40":{"source":"// Pong circuit\n//\n// Kernel for ensuring Pong game rules are valid for a particular state transition\n\nuse dep::std;\n\nstruct GameState {\n  ball_x: i64,\n  ball_y: i64,\n  ball_dx: i64,\n  ball_dy: i64,\n  game_tick: i64,\n  is_first_player: bool,\n  leftPaddle_x: i64,\n  leftPaddle_y: i64,\n  leftPaddle_score: i64,\n  leftPaddle_won: bool,\n  rightPaddle_x: i64,\n  rightPaddle_y: i64,\n  rightPaddle_score: i64,\n  rightPaddle_won: bool,\n}\n\nstruct GameMove {\n  leftPaddle_dy: i64,\n  rightPaddle_dy: i64,\n}\n\nimpl GameMove {\n  pub fn is_empty(self) {\n    assert(self.leftPaddle_dy == 0);\n    assert(self.rightPaddle_dy == 0);\n  }\n}\n\npub fn hash_game_state(state: GameState, move: GameMove) -> Field {\n  std::hash::pedersen_hash([\n    state.ball_x as Field,\n    state.ball_y as Field,\n    state.ball_dx as Field,\n    state.ball_dy as Field,\n    state.game_tick as Field,\n    state.is_first_player as Field,\n    state.leftPaddle_x as Field,\n    state.leftPaddle_y as Field,\n    state.leftPaddle_score as Field,\n    state.leftPaddle_won as Field,\n    state.rightPaddle_x as Field,\n    state.rightPaddle_y as Field,\n    state.rightPaddle_score as Field,\n    state.rightPaddle_won as Field,\n    move.leftPaddle_dy as Field,\n    move.rightPaddle_dy as Field,\n  ])\n}\n\n\n//////////////////////////////////////////\n// utils\n//////////////////////////////////////////\n\nfn signum(x: i64) -> i64 {\n  if (x < 0) {\n    -1\n  } else if (x == 0) {\n    0\n  } else {\n    1\n  }\n}\n\n//////////////////////////////////////////\n// end utils\n//////////////////////////////////////////\n\nglobal canvas_width: i64 = 750;\nglobal canvas_height: i64 = 585;\n\nglobal grid_size: i64 = 15;\nglobal paddleHeight: i64 = 80; // grid_size * 5;\nglobal maxPaddleY: i64 = 495; // canvas_height - grid_size - paddleHeight;\nglobal max_game_ticks: i64 = 128;\nglobal paddleSpeed: i64 = 6;\nglobal ballSpeed: i64 = 5;\n\nglobal canvas_width_half: i64 = 375; // == 750 // 2\nglobal canvas_height_half: i64 = 292; // == 585 // 2\nglobal paddleHeight_half: i64 = 40;\nglobal paddle_y0: i64 = 252; // canvas_height_half - paddleHeight_half;\n\n\nstruct GameObject {\n  x: i64,\n  y: i64,\n  width: i64,\n  height: i64,\n  dy: i64,\n}\n\n\n// // check for collision between two objects using axis-aligned bounding box (AABB)\n// // @see https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection\n// function collides(obj1, obj2) {\n//   return obj1.x < obj2.x + obj2.width &&\n//          obj1.x + obj1.width > obj2.x &&\n//          obj1.y < obj2.y + obj2.height &&\n//          obj1.y + obj1.height > obj2.y;\n// }\nfn collides(obj1: GameObject, obj2: GameObject) -> bool {\n  obj1.x < obj2.x + obj2.width &\n  obj1.x + obj1.width > obj2.x &\n  obj1.y < obj2.y + obj2.height &\n  obj1.y + obj1.height > obj2.y\n}\n\n\n// assert initial state valid\npub fn init_pong(state: GameState) {\n  let leftPaddle = GameObject {\n      x: grid_size * 2,\n      y: paddle_y0,\n      width: grid_size,\n      height: paddleHeight,\n      dy: 0,\n  };\n\n  let rightPaddle = GameObject {\n      x: canvas_width - grid_size * 3,\n      y: paddle_y0,\n      width: grid_size,\n      height: paddleHeight,\n      dy: 0,\n  };\n\n  let ball = GameObject {\n    x: canvas_width_half,\n    y: canvas_height_half,\n    width: grid_size,\n    height: grid_size,\n    dy: -ballSpeed,\n  };\n\n  let leftPaddle_won: bool = false;\n  let leftPaddle_score: i64 = 0;\n  let rightPaddle_score: i64 = 0;\n  let rightPaddle_won: bool = false;\n  let game_tick: i64 = 0;\n  let ball_dx: i64 = ballSpeed;\n\n  assert(ball.x            == state.ball_x,            \"unexpected initial tick: ball.x           \");\n  assert(ball.y            == state.ball_y,            \"unexpected initial tick: ball.y           \");\n  assert(ball_dx           == state.ball_dx,           \"unexpected initial tick: ball_dx          \");\n  assert(ball.dy           == state.ball_dy,           \"unexpected initial tick: ball.dy          \");\n  assert(game_tick         == state.game_tick,         \"unexpected initial tick: game_tick        \");\n  assert(leftPaddle.x      == state.leftPaddle_x,      \"unexpected initial tick: leftPaddle_x     \");\n  assert(leftPaddle.y      == state.leftPaddle_y,      \"unexpected initial tick: leftPaddle_y     \");\n  assert(leftPaddle_score  == state.leftPaddle_score,  \"unexpected initial tick: leftPaddle_score \");\n  assert(leftPaddle_won    == state.leftPaddle_won,    \"unexpected initial tick: leftPaddle_won   \");\n  assert(rightPaddle.x     == state.rightPaddle_x,     \"unexpected initial tick: rightPaddle_x    \");\n  assert(rightPaddle.y     == state.rightPaddle_y,     \"unexpected initial tick: rightPaddle_y    \");\n  assert(rightPaddle_score == state.rightPaddle_score, \"unexpected initial tick: rightPaddle_score\");\n  assert(rightPaddle_won   == state.rightPaddle_won,   \"unexpected initial tick: rightPaddle_won  \");\n  assert(                     state.is_first_player,   \"unexpected initial tick: is_first_player  \");\n  // assert(leftPaddle.dy     == state.leftPaddle_dy,     \"unexpected initial tick: leftPaddle_dy    \");\n  // assert(rightPaddle.dy    == state.rightPaddle_dy,    \"unexpected initial tick: rightPaddle_dy   \");\n}\n\n\n// validate state change on following i/o\n//\n// ball_x: i64\n// ball_y: i64\n// ball_dx: i64\n// ball_dy: i64\n// ball_tick: i64\n// leftPaddle_x: i64\n// leftPaddle_y: i64\n// leftPaddle_dy: i64\n// leftPaddle_score: i64\n// rightPaddle_x: i64\n// rightPaddle_y: i64\n// rightPaddle_dy: i64\n// rightPaddle_score: i64\npub fn step_pong(in_state: GameState, move: GameMove, out_state: GameState) {\n  let mut leftPaddle = GameObject {\n      x: in_state.leftPaddle_x,\n      y: in_state.leftPaddle_y,\n      width: grid_size,\n      height: paddleHeight,\n      dy: move.leftPaddle_dy,\n  };\n\n  let mut rightPaddle = GameObject {\n      x: in_state.rightPaddle_x,\n      y: in_state.rightPaddle_y,\n      width: grid_size,\n      height: paddleHeight,\n      dy: move.rightPaddle_dy,\n  };\n\n  let mut ball = GameObject {\n    x: in_state.ball_x,\n    y: in_state.ball_y,\n    width: grid_size,\n    height: grid_size,\n    dy: in_state.ball_dy,\n  };\n\n  let mut leftPaddle_score = in_state.leftPaddle_score;\n  let mut rightPaddle_score = in_state.rightPaddle_score;\n  let mut game_tick = in_state.game_tick;\n  let mut ball_dx = in_state.ball_dx;\n\n  // game active\n  assert(game_tick < max_game_ticks, \"game tick past end of game\");\n\n  // paddle velocity valid\n  assert((leftPaddle.dy == 0) | (leftPaddle.dy == -paddleSpeed) | (leftPaddle.dy == paddleSpeed));\n  assert((rightPaddle.dy == 0) | (rightPaddle.dy == -paddleSpeed) | (rightPaddle.dy == paddleSpeed));\n\n  // move paddles by their velocity\n  leftPaddle.y += leftPaddle.dy;\n  rightPaddle.y += rightPaddle.dy;\n\n  // prevent paddles from going through walls\n  if (leftPaddle.y < grid_size) {\n    leftPaddle.y = grid_size;\n  }\n  else if (leftPaddle.y > maxPaddleY) {\n    leftPaddle.y = maxPaddleY;\n  }\n  \n  if (rightPaddle.y < grid_size) {\n    rightPaddle.y = grid_size;\n  }\n  else if (rightPaddle.y > maxPaddleY) {\n    rightPaddle.y = maxPaddleY;\n  }\n\n  // move ball by its velocity\n  ball.x += ball_dx;\n  ball.y += ball.dy;\n\n  // prevent ball from going through walls by changing its velocity\n  if (ball.y < grid_size) {\n    ball.y = grid_size;\n    ball.dy *= -1;\n  }\n  else if (ball.y + grid_size > canvas_height - grid_size) {\n    ball.y = canvas_height - grid_size * 2;\n    ball.dy *= -1;\n  }\n\n  // points scored: reset ball if it goes past paddle\n  if (ball.x < 0 | ball.x > canvas_width) {\n  \n    if (ball.x < 0) {\n      rightPaddle_score += 1;\n    } else {\n      leftPaddle_score += 1;\n    }\n  \n    ball.x = canvas_width_half;\n    ball.y = canvas_height_half;\n  \n    // swap directions and reset speed\n    ball_dx = ballSpeed * signum(ball_dx) * -1;\n    ball.dy = -ballSpeed * signum(ball.dy) * -1;\n  }\n\n  // check to see if ball collides with paddle. if they do change x velocity\n  if (collides(ball, leftPaddle)) {\n    ball_dx *= -1;\n    ball_dx += signum(ball_dx);\n    ball.dy += signum(ball.dy);\n  \n    // move ball next to the paddle otherwise the collision will happen again\n    // in the next frame\n    ball.x = leftPaddle.x + leftPaddle.width;\n  }\n  else if (collides(ball, rightPaddle)) {\n    ball_dx *= -1;\n    ball_dx += signum(ball_dx);\n    ball.dy += signum(ball.dy);\n  \n    // move ball next to the paddle otherwise the collision will happen again\n    // in the next frame\n    ball.x = rightPaddle.x - ball.width;\n  }\n\n  game_tick += 1;\n  let is_first_player = !in_state.is_first_player;\n\n  assert(ball.x            == out_state.ball_x,            \"unexpected end of tick: ball.x           \");\n  assert(ball.y            == out_state.ball_y,            \"unexpected end of tick: ball.y           \");\n  assert(ball_dx           == out_state.ball_dx,           \"unexpected end of tick: ball_dx          \");\n  assert(ball.dy           == out_state.ball_dy,           \"unexpected end of tick: ball.dy          \");\n  assert(game_tick         == out_state.game_tick,         \"unexpected end of tick: game_tick        \");\n  assert(is_first_player   == out_state.is_first_player,   \"unexpected end of tick: is_first_player  \");\n  assert(leftPaddle.x      == out_state.leftPaddle_x,      \"unexpected end of tick: leftPaddle_x     \");\n  assert(leftPaddle.y      == out_state.leftPaddle_y,      \"unexpected end of tick: leftPaddle_y     \");\n  assert(leftPaddle_score  == out_state.leftPaddle_score,  \"unexpected end of tick: leftPaddle_score \");\n  assert(rightPaddle.x     == out_state.rightPaddle_x,     \"unexpected end of tick: rightPaddle_x    \");\n  assert(rightPaddle.y     == out_state.rightPaddle_y,     \"unexpected end of tick: rightPaddle_y    \");\n  assert(rightPaddle_score == out_state.rightPaddle_score, \"unexpected end of tick: rightPaddle_score\");\n  // assert(leftPaddle.dy     == out_state.leftPaddle_dy,     \"unexpected end of tick: leftPaddle_dy    \");\n  // assert(rightPaddle.dy    == out_state.rightPaddle_dy,    \"unexpected end of tick: rightPaddle_dy   \");\n}\n\n\n\n// end of game assertions\npub fn final_step_pong(state: GameState) {\n  if (max_game_ticks == state.game_tick) {\n    if (state.leftPaddle_score > state.rightPaddle_score) {\n      assert(state.leftPaddle_won);\n      assert(!state.rightPaddle_won);\n    } else if (state.rightPaddle_score > state.leftPaddle_score) {\n      assert(!state.leftPaddle_won);\n      assert(state.rightPaddle_won);\n    } else {\n      assert(!state.leftPaddle_won);\n      assert(!state.rightPaddle_won);\n    }\n  }\n}\n\n\n// fn main(x: Field, y: pub Field) {\n//\n//   let leftPaddle = GameObject {\n//       x: grid_size * 2,\n//       y: paddle_y0,\n//       width: grid_size,\n//       height: paddleHeight,\n//       dy: 0,\n//   };\n//\n//   let rightPaddle = GameObject {\n//       x: canvas_width - grid_size * 3,\n//       y: paddle_y0,\n//       width: grid_size,\n//       height: paddleHeight,\n//       dy: 0,\n//   };\n//\n//   let ball = GameObject {\n//     x: canvas_width_half,\n//     y: canvas_height_half,\n//     width: grid_size,\n//     height: grid_size,\n//     dy: -ballSpeed,\n//   };\n//\n//   let leftPaddle_score: i64 = 0;\n//   let rightPaddle_score: i64 = 0;\n//   let game_tick: i64 = 0;\n//   let ball_dx: i64 = ballSpeed;\n//\n//\n//   init_pong(\n//     ball.x,\n//     ball.y,\n//     ball_dx,\n//     ball.dy,\n//     game_tick,\n//     leftPaddle.x,\n//     leftPaddle.y,\n//     leftPaddle.dy,\n//     leftPaddle_score,\n//     rightPaddle.x,\n//     rightPaddle.y,\n//     rightPaddle.dy,\n//     rightPaddle_score,\n//   );\n//\n//   step_pong(\n//     ball.x,\n//     ball.y,\n//     ball_dx,\n//     ball.dy,\n//     game_tick,\n//     leftPaddle.x,\n//     leftPaddle.y,\n//     leftPaddle.dy,\n//     leftPaddle_score,\n//     rightPaddle.x,\n//     rightPaddle.y,\n//     rightPaddle.dy,\n//     rightPaddle_score,\n//\n//     ball.x + ball_dx,\n//     ball.y + ball.dy,\n//     ball_dx,\n//     ball.dy,\n//     game_tick + 1,\n//     leftPaddle.x,\n//     leftPaddle.y,\n//     leftPaddle.dy,\n//     leftPaddle_score,\n//     rightPaddle.x,\n//     rightPaddle.y,\n//     rightPaddle.dy,\n//     rightPaddle_score,\n//   );\n//\n//   final_step(\n//     max_game_ticks,\n//     leftPaddle_score,\n//     false, // out_leftPaddle_won\n//     rightPaddle_score,\n//     false, // out_rightPaddle_won\n//   );\n//\n//   assert(x != y);\n// }\n//\n// #[test]\n// fn test_main() {\n//     main(1, 2);\n//\n//     // Uncomment to make test fail\n//     // main(1, 1);\n// }\n\n","path":"/Users/michaelklein/Coding/noir/zk-pong/pong_circuit/src/lib.nr"}}}