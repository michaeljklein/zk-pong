{"noir_version":"0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704","hash":3188017303136654784,"abi":{"parameters":[{"name":"index","type":{"kind":"field"},"visibility":"private"},{"name":"game_log","type":{"kind":"array","length":10,"type":{"kind":"struct","path":"pong::GameState","fields":[{"name":"ball_x","type":{"kind":"integer","sign":"signed","width":64}},{"name":"ball_y","type":{"kind":"integer","sign":"signed","width":64}},{"name":"ball_dx","type":{"kind":"integer","sign":"signed","width":64}},{"name":"ball_dy","type":{"kind":"integer","sign":"signed","width":64}},{"name":"game_tick","type":{"kind":"integer","sign":"signed","width":64}},{"name":"is_first_player","type":{"kind":"boolean"}},{"name":"leftPaddle_x","type":{"kind":"integer","sign":"signed","width":64}},{"name":"leftPaddle_y","type":{"kind":"integer","sign":"signed","width":64}},{"name":"leftPaddle_score","type":{"kind":"integer","sign":"signed","width":64}},{"name":"leftPaddle_won","type":{"kind":"boolean"}},{"name":"rightPaddle_x","type":{"kind":"integer","sign":"signed","width":64}},{"name":"rightPaddle_y","type":{"kind":"integer","sign":"signed","width":64}},{"name":"rightPaddle_score","type":{"kind":"integer","sign":"signed","width":64}},{"name":"rightPaddle_won","type":{"kind":"boolean"}}]}},"visibility":"private"},{"name":"game_moves","type":{"kind":"array","length":10,"type":{"kind":"struct","path":"pong::GameMove","fields":[{"name":"leftPaddle_dy","type":{"kind":"integer","sign":"signed","width":64}},{"name":"rightPaddle_dy","type":{"kind":"integer","sign":"signed","width":64}}]}},"visibility":"private"},{"name":"signatures","type":{"kind":"array","length":10,"type":{"kind":"struct","path":"Sig","fields":[{"name":"bytes","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}}]}},"visibility":"private"},{"name":"user_1","type":{"kind":"struct","path":"Pubkey","fields":[{"name":"x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"private"},{"name":"user_2","type":{"kind":"struct","path":"Pubkey","fields":[{"name":"x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"private"}],"param_witnesses":{"game_log":[{"start":1,"end":141}],"game_moves":[{"start":141,"end":161}],"index":[{"start":0,"end":1}],"signatures":[{"start":161,"end":801}],"user_1":[{"start":801,"end":865}],"user_2":[{"start":865,"end":929}]},"return_type":null,"return_witnesses":[]},"bytecode":"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","debug_symbols":"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PP8oaWd49DOsgkc/wyr4yAmLnu8n4ckJK+HRCWt29Pm2pTM8+hlWwZMTVsKzT4mbHcd958fAwp5op+DZp8QCnn1KLODRp8S9Hb+wj4J5gmdPhxP/5dkD3xQ8+3tYAc/+HlbAoxNWwUdOWPY8NAUfOWHZU8sUPPtNp9fw7NliCj5ywrIngCn4yAnLntM12vPEbGx7OcNPCKm6P/+JvVbBk/a9PeH3Wl5/2EY6PlvEPcK+H+9Y2Pt/wIfirzInxFnd8rvM/vrDj6/Lvn32UX3Vf5HU3/+LvKtM9g29x0UfYdFnDID6XugpLvoeFz3HRS9x0WtcdIuLHjdNS9w0LXHTtMZN0xo3TWvcNK1x03TGuJ3vhR43TWvcNK1x07TGTdMaN00tbppa3DS1uGlqcdN0xjSh74UeN00tbppa3DS1uGlqcdO0xU3TFjdNW9w0bXHTdMbYo++FHjdNW9w0bXHTtMVN0xY3TXvcNO1x07THTdMeN01njDj6Xuhx07THTdMeN0173DTtcdN0xE3TETdNR9w0HXHTdMY4o++FHjdNR9w0HXHTdMRN0xE2TesWNk3r9m9O01qe4xYt2cePfqXZUTQZRVNQNBVFYyiahqLpKJpBokkbiga1FyfUXpxQe3FC7cUJtRcn1F6cUHtxQu3FCbUX76i9eEftxTtqL95Re/GO2ot31F68o/biHbUX76i9eEftxRm1F2fUXpxRe3FG7cUZtRdn1F6cUXtxRu3FGbUXZ9ReXFB7cUHtxQW1FxfUXlxQe3FB7cUFtRcX1F5cUHtxQe3FFbUXV9ReXFF7cUXtxRW1F1fUXlxRe3FF7cUVtRdX1F5sqL3YUHuxofZiQ+3FhtqLDbUXG2ovNtRebKi92FB7cUPtxQ21FzfUXtxQe3FD7cUNtRc31F7cUHtxQ+3FDbUXd9Re3FF7cUftxR21F3fUXtxRe3FH7cUdtRd31F7cUXvxQO3FA7UXD9RePFB78UDtxQO1Fw/UXjxQe/FA7cWDtBfbRtqLDXXvzlD37gx178420l5sqHt3hrp3Z6h7d4a6d2eoe3eGundnqHt3hrp3Z6h7d4a6d2eoe3eGundnqHt3hrp3Z6h7d4a6d2eoe3eGundnqHt3hrp3Z6h7d4a6d2eoe3eGundnqHt3hrp3Z6h7d4a6d2eoe3eGundnqHt3hrp3Z6h7d4a6d2eoe3eGundnqHt3hrp3Z6h7d4a6d2eoe3eGundnqHt3hrp3Z6h7d4a6d2eoe3eGundnqHt3hrp3Z6h7d4a6d2eoe3eGundnqHt3hrp3Z6h7d4a6d2eoe3eGundnqHt3hrp3Z6h7d4a6d2eoe3eGundnqHt3hrp3Z6h7d4a6d2eoe3eGundnqHt3hrp3Z6h7d4a6d2eoe3eGundnqHt3hrp3Z6h7d4a6d2eoe3eGundnqHt3hrp3Z6h7d4a6d2eoe3fGuXf3++//Dw==","file_map":{"16":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n    \n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(_self: Self, _bit_size: u32) -> [u1] {}\n    \n    #[builtin(to_be_bits)]\n    fn __to_be_bits(_self: Self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(_self: Self, _bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(_self: Self, _radix: u32, _result_len: u32) -> [u8] {}\n    \n    #[builtin(to_be_radix)]\n    fn __to_be_radix(_self: Self, _radix: u32, _result_len: u32) -> [u8] {}\n\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x âˆˆ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> Field {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"24":{"source":"mod poseidon;\nmod mimc;\n\n#[foreign(sha256)]\npub fn sha256<N>(_input: [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake2s)]\npub fn blake2s<N>(_input: [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake3)]\npub fn blake3<N>(_input: [u8; N]) -> [u8; 32] {}\n\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint {\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(_input: [Field; N], _separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\npub fn pedersen_hash<N>(input: [Field; N]) -> Field {\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(_input: [Field; N], _separator: u32) -> Field {}\n\npub fn hash_to_field<N>(_input: [Field; N]) -> Field {\n    let mut inputs_as_bytes = [];\n\n    for i in 0..N {\n        let input_bytes = _input[i].to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\npub fn keccak256<N>(_input: [u8; N], _message_size: u32) -> [u8; 32] {}\n\n","path":"std/hash.nr"},"39":{"source":"// Endgame circuit\n//\n// Kernel for certifying a game log once it's ended\n\nuse dep::std;\nuse dep::pong::{GameMove, GameState, init_pong, step_pong, final_step_pong, hash_game_state};\n\n\n// global MAX_PINGS = 256;\nglobal MAX_PINGS = 10;\n\n\nstruct Sig {\n  bytes: [u8; 64],\n}\n\n\nstruct Pubkey {\n  x: [u8; 32],\n  y: [u8; 32],\n}\n\nimpl Pubkey {\n  fn verify(self, sig: Sig, x: Field) {\n    let message_slice = x.to_le_radix(256, 32);\n    let mut message: [u8; 32] = [0; 32];\n    for i in 0..32 {\n        message[i] = message_slice[i];\n    }\n    assert(std::ecdsa_secp256k1::verify_signature(self.x, self.y, sig.bytes, message));\n  }\n}\n\n\ntrait StepState<T> {\n  fn assert_initial_state(self);\n  fn assert_step(self, move: T, new_state: Self);\n  fn assert_final_state(self);\n  fn is_first_user(self) -> bool;\n  fn hash_to_field(self, move: T) -> Field;\n}\n\nimpl StepState<GameMove> for GameState {\n  fn assert_initial_state(self) {\n    init_pong(self)\n  }\n\n  fn assert_step(self, move: GameMove, new_state: Self) {\n    step_pong(self, move, new_state)\n  }\n\n  fn assert_final_state(self) {\n    final_step_pong(self)\n  }\n\n  fn is_first_user(self) -> bool {\n    self.is_first_player\n  }\n\n  fn hash_to_field(self, move: GameMove) -> Field {\n    hash_game_state(self, move)\n  }\n}\n\n\n// step kernel: (state_N, state_N', move_N', sig_N')\n// - state_N' = step(move_N', state_N)\n// - verify(p(N % 2), state_N', sig_N')\n//\n// if i == 0:\n//   // initialize\n//   old_state = initial_state\n//   new_state = game_log[i].0\n//   move      = game_log[i].1\n//   sig       = game_log[i].2\n// else:\n//   // step\n//   old_state = game_log[i].0\n//   new_state = game_log[i+1].0\n//   move      = game_log[i+1].1\n//   sig       = game_log[i+1].2\n//\n// step_kernel(old_state, new_state, move, sig)\n//\n// // finalize\n// if index + 1 == MAX_PINGS:\n//   finalize_kernel\n// end\nfn step_kernel<S, T>(\n  old_state: S,\n  new_state: S,\n  move: T,\n  index: Field,\n  sig: Sig,\n  user_1: Pubkey,\n  user_2: Pubkey,\n)\nwhere\n  S: StepState<T>\n{\n    // bootstrap with old_state = new_state = initial_state\n    if (index == 0) {\n        old_state.assert_initial_state();\n        new_state.assert_initial_state();\n    }\n\n    if (index + 1 == MAX_PINGS) {\n        new_state.assert_final_state();\n    }\n\n    // do this in state.assert_step()\n    // assert(old_state.is_first_user != new_state.is_first_user);\n    old_state.assert_step(move, new_state);\n\n    let current_user = if new_state.is_first_user() {\n        user_1\n    } else {\n        user_2\n    };\n    current_user.verify(sig, new_state.hash_to_field(move));\n}\n\nfn main(\n  index: Field,\n  game_log: [GameState; MAX_PINGS],\n  game_moves: [GameMove; MAX_PINGS],\n  signatures: [Sig; MAX_PINGS],\n  user_1: Pubkey,\n  user_2: Pubkey,\n) {\n  if (index == 0) {\n    assert(game_moves[0].leftPaddle_dy == game_moves[1].leftPaddle_dy);\n    assert(game_moves[0].rightPaddle_dy == game_moves[1].rightPaddle_dy);\n    assert(signatures[0].bytes == signatures[1].bytes);\n  }\n  step_kernel(\n    game_log[index], \n    game_log[index+1], \n    game_moves[index+1], \n    index,\n    signatures[index+1], \n    user_1,\n    user_2\n  )\n}\n\n","path":"/Users/michaelklein/Coding/noir/zk-pong/endgame_circuit/src/main.nr"},"40":{"source":"// Pong circuit\n//\n// Kernel for ensuring Pong game rules are valid for a particular state transition\n\nuse dep::std;\n\nstruct GameState {\n  ball_x: i64,\n  ball_y: i64,\n  ball_dx: i64,\n  ball_dy: i64,\n  game_tick: i64,\n  is_first_player: bool,\n  leftPaddle_x: i64,\n  leftPaddle_y: i64,\n  leftPaddle_score: i64,\n  leftPaddle_won: bool,\n  rightPaddle_x: i64,\n  rightPaddle_y: i64,\n  rightPaddle_score: i64,\n  rightPaddle_won: bool,\n}\n\nstruct GameMove {\n  leftPaddle_dy: i64,\n  rightPaddle_dy: i64,\n}\n\nimpl GameMove {\n  pub fn is_empty(self) {\n    assert(self.leftPaddle_dy == 0);\n    assert(self.rightPaddle_dy == 0);\n  }\n}\n\npub fn hash_game_state(state: GameState, move: GameMove) -> Field {\n  std::hash::pedersen_hash([\n    state.ball_x as Field,\n    state.ball_y as Field,\n    state.ball_dx as Field,\n    state.ball_dy as Field,\n    state.game_tick as Field,\n    state.is_first_player as Field,\n    state.leftPaddle_x as Field,\n    state.leftPaddle_y as Field,\n    state.leftPaddle_score as Field,\n    state.leftPaddle_won as Field,\n    state.rightPaddle_x as Field,\n    state.rightPaddle_y as Field,\n    state.rightPaddle_score as Field,\n    state.rightPaddle_won as Field,\n    move.leftPaddle_dy as Field,\n    move.rightPaddle_dy as Field,\n  ])\n}\n\n\n//////////////////////////////////////////\n// utils\n//////////////////////////////////////////\n\nfn signum(x: i64) -> i64 {\n  if (x < 0) {\n    -1\n  } else if (x == 0) {\n    0\n  } else {\n    1\n  }\n}\n\n//////////////////////////////////////////\n// end utils\n//////////////////////////////////////////\n\nglobal canvas_width: i64 = 750;\nglobal canvas_height: i64 = 585;\n\nglobal grid_size: i64 = 15;\nglobal paddleHeight: i64 = 80; // grid_size * 5;\nglobal maxPaddleY: i64 = 495; // canvas_height - grid_size - paddleHeight;\nglobal max_game_ticks: i64 = 128;\nglobal paddleSpeed: i64 = 6;\nglobal ballSpeed: i64 = 5;\n\nglobal canvas_width_half: i64 = 375; // == 750 // 2\nglobal canvas_height_half: i64 = 292; // == 585 // 2\nglobal paddleHeight_half: i64 = 40;\nglobal paddle_y0: i64 = 252; // canvas_height_half - paddleHeight_half;\n\n\nstruct GameObject {\n  x: i64,\n  y: i64,\n  width: i64,\n  height: i64,\n  dy: i64,\n}\n\n\n// // check for collision between two objects using axis-aligned bounding box (AABB)\n// // @see https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection\n// function collides(obj1, obj2) {\n//   return obj1.x < obj2.x + obj2.width &&\n//          obj1.x + obj1.width > obj2.x &&\n//          obj1.y < obj2.y + obj2.height &&\n//          obj1.y + obj1.height > obj2.y;\n// }\nfn collides(obj1: GameObject, obj2: GameObject) -> bool {\n  obj1.x < obj2.x + obj2.width &\n  obj1.x + obj1.width > obj2.x &\n  obj1.y < obj2.y + obj2.height &\n  obj1.y + obj1.height > obj2.y\n}\n\n\n// assert initial state valid\npub fn init_pong(state: GameState) {\n  let leftPaddle = GameObject {\n      x: grid_size * 2,\n      y: paddle_y0,\n      width: grid_size,\n      height: paddleHeight,\n      dy: 0,\n  };\n\n  let rightPaddle = GameObject {\n      x: canvas_width - grid_size * 3,\n      y: paddle_y0,\n      width: grid_size,\n      height: paddleHeight,\n      dy: 0,\n  };\n\n  let ball = GameObject {\n    x: canvas_width_half,\n    y: canvas_height_half,\n    width: grid_size,\n    height: grid_size,\n    dy: -ballSpeed,\n  };\n\n  let leftPaddle_won: bool = false;\n  let leftPaddle_score: i64 = 0;\n  let rightPaddle_score: i64 = 0;\n  let rightPaddle_won: bool = false;\n  let game_tick: i64 = 0;\n  let ball_dx: i64 = ballSpeed;\n\n  assert(ball.x            == state.ball_x,            \"unexpected initial tick: ball.x           \");\n  assert(ball.y            == state.ball_y,            \"unexpected initial tick: ball.y           \");\n  assert(ball_dx           == state.ball_dx,           \"unexpected initial tick: ball_dx          \");\n  assert(ball.dy           == state.ball_dy,           \"unexpected initial tick: ball.dy          \");\n  assert(game_tick         == state.game_tick,         \"unexpected initial tick: game_tick        \");\n  assert(leftPaddle.x      == state.leftPaddle_x,      \"unexpected initial tick: leftPaddle_x     \");\n  assert(leftPaddle.y      == state.leftPaddle_y,      \"unexpected initial tick: leftPaddle_y     \");\n  assert(leftPaddle_score  == state.leftPaddle_score,  \"unexpected initial tick: leftPaddle_score \");\n  assert(leftPaddle_won    == state.leftPaddle_won,    \"unexpected initial tick: leftPaddle_won   \");\n  assert(rightPaddle.x     == state.rightPaddle_x,     \"unexpected initial tick: rightPaddle_x    \");\n  assert(rightPaddle.y     == state.rightPaddle_y,     \"unexpected initial tick: rightPaddle_y    \");\n  assert(rightPaddle_score == state.rightPaddle_score, \"unexpected initial tick: rightPaddle_score\");\n  assert(rightPaddle_won   == state.rightPaddle_won,   \"unexpected initial tick: rightPaddle_won  \");\n  assert(                     state.is_first_player,   \"unexpected initial tick: is_first_player  \");\n  // assert(leftPaddle.dy     == state.leftPaddle_dy,     \"unexpected initial tick: leftPaddle_dy    \");\n  // assert(rightPaddle.dy    == state.rightPaddle_dy,    \"unexpected initial tick: rightPaddle_dy   \");\n}\n\n\n// validate state change on following i/o\n//\n// ball_x: i64\n// ball_y: i64\n// ball_dx: i64\n// ball_dy: i64\n// ball_tick: i64\n// leftPaddle_x: i64\n// leftPaddle_y: i64\n// leftPaddle_dy: i64\n// leftPaddle_score: i64\n// rightPaddle_x: i64\n// rightPaddle_y: i64\n// rightPaddle_dy: i64\n// rightPaddle_score: i64\npub fn step_pong(in_state: GameState, move: GameMove, out_state: GameState) {\n  let mut leftPaddle = GameObject {\n      x: in_state.leftPaddle_x,\n      y: in_state.leftPaddle_y,\n      width: grid_size,\n      height: paddleHeight,\n      dy: move.leftPaddle_dy,\n  };\n\n  let mut rightPaddle = GameObject {\n      x: in_state.rightPaddle_x,\n      y: in_state.rightPaddle_y,\n      width: grid_size,\n      height: paddleHeight,\n      dy: move.rightPaddle_dy,\n  };\n\n  let mut ball = GameObject {\n    x: in_state.ball_x,\n    y: in_state.ball_y,\n    width: grid_size,\n    height: grid_size,\n    dy: in_state.ball_dy,\n  };\n\n  let mut leftPaddle_score = in_state.leftPaddle_score;\n  let mut rightPaddle_score = in_state.rightPaddle_score;\n  let mut game_tick = in_state.game_tick;\n  let mut ball_dx = in_state.ball_dx;\n\n  // game active\n  assert(game_tick < max_game_ticks, \"game tick past end of game\");\n\n  // paddle velocity valid\n  assert((leftPaddle.dy == 0) | (leftPaddle.dy == -paddleSpeed) | (leftPaddle.dy == paddleSpeed));\n  assert((rightPaddle.dy == 0) | (rightPaddle.dy == -paddleSpeed) | (rightPaddle.dy == paddleSpeed));\n\n  // move paddles by their velocity\n  leftPaddle.y += leftPaddle.dy;\n  rightPaddle.y += rightPaddle.dy;\n\n  // prevent paddles from going through walls\n  if (leftPaddle.y < grid_size) {\n    leftPaddle.y = grid_size;\n  }\n  else if (leftPaddle.y > maxPaddleY) {\n    leftPaddle.y = maxPaddleY;\n  }\n  \n  if (rightPaddle.y < grid_size) {\n    rightPaddle.y = grid_size;\n  }\n  else if (rightPaddle.y > maxPaddleY) {\n    rightPaddle.y = maxPaddleY;\n  }\n\n  // move ball by its velocity\n  ball.x += ball_dx;\n  ball.y += ball.dy;\n\n  // prevent ball from going through walls by changing its velocity\n  if (ball.y < grid_size) {\n    ball.y = grid_size;\n    ball.dy *= -1;\n  }\n  else if (ball.y + grid_size > canvas_height - grid_size) {\n    ball.y = canvas_height - grid_size * 2;\n    ball.dy *= -1;\n  }\n\n  // points scored: reset ball if it goes past paddle\n  if (ball.x < 0 | ball.x > canvas_width) {\n  \n    if (ball.x < 0) {\n      rightPaddle_score += 1;\n    } else {\n      leftPaddle_score += 1;\n    }\n  \n    ball.x = canvas_width_half;\n    ball.y = canvas_height_half;\n  \n    // swap directions and reset speed\n    ball_dx = ballSpeed * signum(ball_dx) * -1;\n    ball.dy = -ballSpeed * signum(ball.dy) * -1;\n  }\n\n  // check to see if ball collides with paddle. if they do change x velocity\n  if (collides(ball, leftPaddle)) {\n    ball_dx *= -1;\n    ball_dx += signum(ball_dx);\n    ball.dy += signum(ball.dy);\n  \n    // move ball next to the paddle otherwise the collision will happen again\n    // in the next frame\n    ball.x = leftPaddle.x + leftPaddle.width;\n  }\n  else if (collides(ball, rightPaddle)) {\n    ball_dx *= -1;\n    ball_dx += signum(ball_dx);\n    ball.dy += signum(ball.dy);\n  \n    // move ball next to the paddle otherwise the collision will happen again\n    // in the next frame\n    ball.x = rightPaddle.x - ball.width;\n  }\n\n  game_tick += 1;\n  let is_first_player = !in_state.is_first_player;\n\n  assert(ball.x            == out_state.ball_x,            \"unexpected end of tick: ball.x           \");\n  assert(ball.y            == out_state.ball_y,            \"unexpected end of tick: ball.y           \");\n  assert(ball_dx           == out_state.ball_dx,           \"unexpected end of tick: ball_dx          \");\n  assert(ball.dy           == out_state.ball_dy,           \"unexpected end of tick: ball.dy          \");\n  assert(game_tick         == out_state.game_tick,         \"unexpected end of tick: game_tick        \");\n  assert(is_first_player   == out_state.is_first_player,   \"unexpected end of tick: is_first_player  \");\n  assert(leftPaddle.x      == out_state.leftPaddle_x,      \"unexpected end of tick: leftPaddle_x     \");\n  assert(leftPaddle.y      == out_state.leftPaddle_y,      \"unexpected end of tick: leftPaddle_y     \");\n  assert(leftPaddle_score  == out_state.leftPaddle_score,  \"unexpected end of tick: leftPaddle_score \");\n  assert(rightPaddle.x     == out_state.rightPaddle_x,     \"unexpected end of tick: rightPaddle_x    \");\n  assert(rightPaddle.y     == out_state.rightPaddle_y,     \"unexpected end of tick: rightPaddle_y    \");\n  assert(rightPaddle_score == out_state.rightPaddle_score, \"unexpected end of tick: rightPaddle_score\");\n  // assert(leftPaddle.dy     == out_state.leftPaddle_dy,     \"unexpected end of tick: leftPaddle_dy    \");\n  // assert(rightPaddle.dy    == out_state.rightPaddle_dy,    \"unexpected end of tick: rightPaddle_dy   \");\n}\n\n\n\n// end of game assertions\npub fn final_step_pong(state: GameState) {\n  if (max_game_ticks == state.game_tick) {\n    if (state.leftPaddle_score > state.rightPaddle_score) {\n      assert(state.leftPaddle_won);\n      assert(!state.rightPaddle_won);\n    } else if (state.rightPaddle_score > state.leftPaddle_score) {\n      assert(!state.leftPaddle_won);\n      assert(state.rightPaddle_won);\n    } else {\n      assert(!state.leftPaddle_won);\n      assert(!state.rightPaddle_won);\n    }\n  }\n}\n\n\n// fn main(x: Field, y: pub Field) {\n//\n//   let leftPaddle = GameObject {\n//       x: grid_size * 2,\n//       y: paddle_y0,\n//       width: grid_size,\n//       height: paddleHeight,\n//       dy: 0,\n//   };\n//\n//   let rightPaddle = GameObject {\n//       x: canvas_width - grid_size * 3,\n//       y: paddle_y0,\n//       width: grid_size,\n//       height: paddleHeight,\n//       dy: 0,\n//   };\n//\n//   let ball = GameObject {\n//     x: canvas_width_half,\n//     y: canvas_height_half,\n//     width: grid_size,\n//     height: grid_size,\n//     dy: -ballSpeed,\n//   };\n//\n//   let leftPaddle_score: i64 = 0;\n//   let rightPaddle_score: i64 = 0;\n//   let game_tick: i64 = 0;\n//   let ball_dx: i64 = ballSpeed;\n//\n//\n//   init_pong(\n//     ball.x,\n//     ball.y,\n//     ball_dx,\n//     ball.dy,\n//     game_tick,\n//     leftPaddle.x,\n//     leftPaddle.y,\n//     leftPaddle.dy,\n//     leftPaddle_score,\n//     rightPaddle.x,\n//     rightPaddle.y,\n//     rightPaddle.dy,\n//     rightPaddle_score,\n//   );\n//\n//   step_pong(\n//     ball.x,\n//     ball.y,\n//     ball_dx,\n//     ball.dy,\n//     game_tick,\n//     leftPaddle.x,\n//     leftPaddle.y,\n//     leftPaddle.dy,\n//     leftPaddle_score,\n//     rightPaddle.x,\n//     rightPaddle.y,\n//     rightPaddle.dy,\n//     rightPaddle_score,\n//\n//     ball.x + ball_dx,\n//     ball.y + ball.dy,\n//     ball_dx,\n//     ball.dy,\n//     game_tick + 1,\n//     leftPaddle.x,\n//     leftPaddle.y,\n//     leftPaddle.dy,\n//     leftPaddle_score,\n//     rightPaddle.x,\n//     rightPaddle.y,\n//     rightPaddle.dy,\n//     rightPaddle_score,\n//   );\n//\n//   final_step(\n//     max_game_ticks,\n//     leftPaddle_score,\n//     false, // out_leftPaddle_won\n//     rightPaddle_score,\n//     false, // out_rightPaddle_won\n//   );\n//\n//   assert(x != y);\n// }\n//\n// #[test]\n// fn test_main() {\n//     main(1, 2);\n//\n//     // Uncomment to make test fail\n//     // main(1, 1);\n// }\n\n","path":"/Users/michaelklein/Coding/noir/zk-pong/pong_circuit/src/lib.nr"}}}